1,3d0
< -------------------------------------------------------------------------------
< -- emac - entity/architecture pair
< -------------------------------------------------------------------------------
42a40
> ------------------------------------------------------------------------
44,49c42,54
< -------------------------------------------------------------------------------
< -- Filename     : emac.vhd
< -- Version      : v1.00.a
< -- Description  : Design file for the Ethernet Lite MAC. 
< -- VHDL-Standard: VHDL'93
< -------------------------------------------------------------------------------
---
> --  NetFPGA-10G http://www.netfpga.org
> --
> --  Module:
> --          mdio_ipif
> --
> --  Description:
> --          MDIO engine IP interface patched from emac.vhd of
> --          axi_ethernetlite pcore
> --                 
> --  Revision history:
> --          2010/12/8 hyzeng: Initial check-in
> --
> ------------------------------------------------------------------------
52c57
< --  axi_ethernetlite.vhd
---
> --  nf10_mdio.vhd
55c60
< --      \-- xemac.vhd
---
> --      \-- mdio_ipif.vhd
58,84d62
< --           \-- emac_dpram.vhd                     
< --           \    \                     
< --           \    \-- RAMB16_S4_S36
< --           \                          
< --           \    
< --           \-- emac.vhd                     
< --                \                     
< --                \-- MacAddrRAM                   
< --                \-- receive.vhd
< --                \      rx_statemachine.vhd
< --                \      rx_intrfce.vhd
< --                \         async_fifo_fg.vhd
< --                \      crcgenrx.vhd
< --                \                     
< --                \-- transmit.vhd
< --                       crcgentx.vhd
< --                          crcnibshiftreg
< --                       tx_intrfce.vhd
< --                          async_fifo_fg.vhd
< --                       tx_statemachine.vhd
< --                       deferral.vhd
< --                          cntr5bit.vhd
< --                          defer_state.vhd
< --                       bocntr.vhd
< --                          lfsr16.vhd
< --                       msh_cnt.vhd
< --                       ld_arith_reg.vhd
87,112d64
< -- Author:    PVK
< -- History:    
< -- PVK        06/07/2010     First Version
< -- ^^^^^^
< -- First version.  
< -- ~~~~~~
< -------------------------------------------------------------------------------
< -- Naming Conventions:
< --      active low signals:                     "*_n"
< --      clock signals:                          "Clk", "clk_div#", "clk_#x" 
< --      reset signals:                          "Rst", "rst_n" 
< --      generics:                               "C_*" 
< --      user defined types:                     "*_TYPE" 
< --      state machine next state:               "*_ns" 
< --      state machine current state:            "*_cs" 
< --      combinatorial signals:                  "*_com" 
< --      pipelined or register delay signals:    "*_d#" 
< --      counter signals:                        "*cnt*"
< --      clock enable signals:                   "*_ce" 
< --      internal version of output port         "*_i"
< --      device pins:                            "*_pin" 
< --      ports:                                  - Names begin with Uppercase 
< --      processes:                              "*_PROCESS" 
< --      component instantiations:               "<ENTITY_>I_<#|FUNC>
< -------------------------------------------------------------------------------
< -- 
116c68
< use ieee.std_logic_unsigned.all;
---
> use ieee.numeric_std.all;
119c71
< -- axi_ethernetlite_v1_00_a library is used for axi_ethernetlite_v1_00_a 
---
> -- axi_ethernetlite_v1_00_a library is used for axi_ethernetlite_v1_00_a
122,124c74,83
< library axi_ethernetlite_v1_00_a;
< use axi_ethernetlite_v1_00_a.mac_pkg.all;
< use axi_ethernetlite_v1_00_a.all;
---
> library nf10_mdio_v1_00_a;
> use nf10_mdio_v1_00_a.all;
> 
> -------------------------------------------------------------------------------
> -- proc common package of the proc common library is used for different
> -- function declarations
> -------------------------------------------------------------------------------
> library proc_common_v3_00_a;
> use proc_common_v3_00_a.all;
> use proc_common_v3_00_a.family.all;
134,174d92
< -- Definition of Generics:
< -------------------------------------------------------------------------------
< --  C_DUPLEX               -- 1 = full duplex, 0 = half duplex
< --  NODE_MAC               -- EMACLite MAC address
< --  C_FAMILY               -- Target device family 
< -------------------------------------------------------------------------------
< -- Definition of Ports:
< --
< --  Clk                    -- System Clock
< --  Rst                    -- System Reset
< --  PHY_tx_clk             -- Ethernet tranmit clock
< --  PHY_rx_clk             -- Ethernet receive clock
< --  PHY_crs                -- Ethernet carrier sense
< --  PHY_dv                 -- Ethernet receive data valid
< --  PHY_rx_data            -- Ethernet receive data
< --  PHY_col                -- Ethernet collision indicator
< --  PHY_rx_er              -- Ethernet receive error
< --  PHY_rst_n              -- Ethernet PHY Reset
< --  PHY_tx_en              -- Ethernet transmit enable
< --  PHY_tx_data            -- Ethernet transmit data
< --  Tx_DPM_ce              -- TX buffer chip enable
< --  Tx_DPM_adr             -- Tx buffer address
< --  Tx_DPM_wr_data         -- TX buffer write data
< --  Tx_DPM_rd_data         -- TX buffer read data
< --  Tx_DPM_wr_rd_n         -- TX buffer write/read enable
< --  Tx_done                -- Transmit done
< --  Tx_pong_ping_l         -- TX Ping/Pong buffer enable
< --  Tx_idle                -- Transmit idle
< --  Rx_idle                -- Receive idle
< --  Rx_DPM_ce              -- RX buffer chip enable
< --  Rx_DPM_adr             -- RX buffer address
< --  Rx_DPM_wr_data         -- RX buffer write data
< --  Rx_DPM_rd_data         -- RX buffer read data
< --  Rx_DPM_wr_rd_n         -- RX buffer write/read enable
< --  Rx_done                -- Receive done
< --  Rx_pong_ping_l         -- RX Ping/Pong buffer enable
< --  Tx_packet_length       -- Transmit packet length
< --  Transmit_start         -- Transmit Start
< --  Mac_program_start      -- MAC Program start
< --  Rx_buffer_ready        -- RX Buffer ready indicator
< -------------------------------------------------------------------------------
177c95
< entity emac is
---
> entity mdio_ipif is
179,215c97,117
<     C_DUPLEX          : integer    := 1; 
<       -- 1 = full duplex, 0 = half duplex       
<     NODE_MAC          : bit_vector := x"00005e00FACE";
<     C_FAMILY          : string     := "virtex6"
<     );                
<   port (              
<     Clk               : in  std_logic;
<     Rst               : in  std_logic;
<     Phy_tx_clk        : in  std_logic;
<     Phy_rx_clk        : in  std_logic;
<     Phy_crs           : in  std_logic;
<     Phy_dv            : in  std_logic;
<     Phy_rx_data       : in  std_logic_vector (0 to 3);
<     Phy_col           : in  std_logic;
<     Phy_rx_er         : in  std_logic;
<     Phy_tx_en         : out std_logic;
<     Phy_tx_data       : out std_logic_vector (0 to 3);
<     Tx_DPM_ce         : out std_logic;
<     Tx_DPM_adr        : out std_logic_vector (0 to 11);
<     Tx_DPM_wr_data    : out std_logic_vector (0 to 3);
<     Tx_DPM_rd_data    : in  std_logic_vector (0 to 3);
<     Tx_DPM_wr_rd_n    : out std_logic;
<     Tx_done           : out std_logic;
<     Tx_pong_ping_l    : in  std_logic;
<     Tx_idle           : out std_logic;
<     Rx_idle           : out std_logic;
<     Rx_DPM_ce         : out std_logic;
<     Rx_DPM_adr        : out std_logic_vector (0 to 11);
<     Rx_DPM_wr_data    : out std_logic_vector (0 to 3);
<     Rx_DPM_rd_data    : in  std_logic_vector (0 to 3);
<     Rx_DPM_wr_rd_n    : out std_logic;
<     Rx_done           : out std_logic;
<     Rx_pong_ping_l    : in  std_logic;
<     Tx_packet_length  : in  std_logic_vector(0 to 15);
<     Transmit_start    : in  std_logic;
<     Mac_program_start : in  std_logic;
<     Rx_buffer_ready   : in  std_logic
---
>     C_FAMILY                : string := "virtex6";
>     C_BASEADDR              : std_logic_vector := X"60000000";
>                                      --  Assigned Base Address for
>                                      --  this device (system byte address)
>     C_HIGHADDR              : std_logic_vector := X"60003fff";
>                                      -- Maximum Address for this device (system
>                                      -- byte address xxxx3fff)
>                                      -- (using word addressing for each byte)
> 
>     C_S_AXI_ADDR_WIDTH      : integer := 32;
>     C_S_AXI_DATA_WIDTH      : integer := 32;
>     C_S_AXI_ACLK_PERIOD_PS  : integer := 10000;
>     C_DUPLEX                : integer := 1; -- 1 = full duplex, 0 = half duplex
>     C_RX_PING_PONG          : integer := 0; -- 1 = ping-pong memory used for
>                                             --     receive buffer
>     C_TX_PING_PONG          : integer := 0; -- 1 = ping-pong memory used for
>                                             --     transmit buffer
>     C_INCLUDE_MDIO          : integer := 1; -- 1 = Include MDIO interface
>                                             -- 0 = No MDIO interface
>     NODE_MAC                : bit_vector := x"00005e00FACE"
>                                             --  power up defaul MAC address
217c119,145
< end emac;
---
>   port (
>     Clk           : in  std_logic;
>     Rst           : in  std_logic;
>     IP2INTC_Irpt  : out std_logic;
> 
> 
>     -- Controls to the IP/IPIF modules
>     IP2Bus_Data   : out std_logic_vector((C_S_AXI_DATA_WIDTH-1) downto 0 );
>     IP2Bus_Error  : out std_logic;
>     Bus2IP_Addr   : in  std_logic_vector(12 downto 0);
>     Bus2IP_Data   : in  std_logic_vector((C_S_AXI_DATA_WIDTH-1) downto 0);
>     Bus2IP_BE     : in  std_logic_vector(((C_S_AXI_DATA_WIDTH/8)-1)downto 0);
>     Bus2IP_RdCE   : in  std_logic;
>     Bus2IP_WrCE   : in  std_logic;
>     Bus2IP_Burst  : in  std_logic;
> 
>     -- MDIO Interface
>     PHY_MDIO_I    : in  std_logic;
>     PHY_MDIO_O    : out std_logic;
>     PHY_MDIO_T    : out std_logic;
>     PHY_MDC       : out std_logic
>    );
> 
> end mdio_ipif;
> 
> 
> architecture imp of mdio_ipif is
219d146
< architecture imp of emac is
224,243c151,165
<   signal phy_col_d1            : std_logic; -- added 3-03-05 MSH
<   signal phy_crs_d1            : std_logic; -- added 3-03-05 MSH
<   signal rxbuffer_addr         : std_logic_vector(0 to 11);
<   signal rx_addr_en            : std_logic;
<   signal rx_start              : std_logic;
<   signal txbuffer_addr         : std_logic_vector(0 to 11);
<   signal tx_addr_en            : std_logic;
<   signal tx_start              : std_logic;
<   signal mac_addr_ram_addr     : std_logic_vector(0 to 3);
<   signal mac_addr_ram_addr_rd  : std_logic_vector(0 to 3);
<   signal mac_addr_ram_we       : std_logic;
<   signal mac_addr_ram_addr_wr  : std_logic_vector(0 to 3);
<   signal mac_addr_ram_data     : std_logic_vector(0 to 3);
<   signal txClkEn               : std_logic;
<   signal tx_clk_reg_d1         : std_logic;  
<   signal tx_clk_reg_d2         : std_logic;
<   signal mac_tx_frame_length   : std_logic_vector(0 to 15);
<   signal nibbleLength          : std_logic_vector(0 to 11);
<   signal nibbleLength_orig     : std_logic_vector(0 to 11);
<   signal en_pad                : std_logic;
---
> constant MDIO_CNT         : integer := ((200000/C_S_AXI_ACLK_PERIOD_PS)+1);
> constant IP2BUS_DATA_ZERO : std_logic_vector(0 to 31) := X"00000000";
> 
> 
> -------------------------------------------------------------------------------
> --  Signal and Type Declarations
> -------------------------------------------------------------------------------
> signal reg_access             : std_logic;
> signal reg_en                 : std_logic;
> signal mdio_data_out          : std_logic_vector(31 downto 0);
> signal mdio_reg_en            : std_logic;
> signal reg_access_d1          : std_logic;
> signal reg_access_i           : std_logic;
> 
> -------------------------------------------------------------------------------
247a170,185
> component SRL16E
>     generic (
>       INIT : bit_vector := X"0000"
>       );
> 
>   port  (
>     Q   : out std_logic; --[out]
>     A0  : in  std_logic; --[in]
>     A1  : in  std_logic; --[in]
>     A2  : in  std_logic; --[in]
>     A3  : in  std_logic; --[in]
>     CE  : in  std_logic; --[in]
>     CLK : in  std_logic; --[in]
>     D   : in  std_logic  --[in]
>   );
> end component;
249d186
< -- The following components are the building blocks of the EMAC
257c194
<     );
---
>   );
259a197,216
> component FDRE
>   port (
>     Q  : out std_logic;
>     C  : in std_logic;
>     CE : in std_logic;
>     D  : in std_logic;
>     R  : in std_logic
>   );
> end component;
> 
> component LUT4
>    generic(INIT : bit_vector);
>    port (
>      O  : out std_logic;
>      I0 : in std_logic;
>      I1 : in std_logic;
>      I2 : in std_logic;
>      I3 : in std_logic
>    );
> end component;
263a221,224
> 
>    IP2Bus_Error <= '0';
>    IP2INTC_Irpt <= '0';
> 
265,396c226,232
<    -- Receive Interface
<    ----------------------------------------------------------------------------
<    RX: entity axi_ethernetlite_v1_00_a.receive
<      generic map
<        (
<        C_DUPLEX => C_DUPLEX,
<        C_FAMILY => C_FAMILY   
<        )    
<      port map
<        (   
<        Clk                  => Clk,
<        Rst                  => Rst,
<        Phy_rx_clk           => Phy_rx_clk,
<        Phy_dv               => Phy_dv,
<        Phy_rx_data          => Phy_rx_data, 
<        Phy_rx_col           => phy_col_d1, 
<        Phy_rx_er            => Phy_rx_er,
<        Rx_addr_en           => rx_addr_en,
<        Rx_start             => rx_start,
<        Rx_done              => Rx_done,
<        Rx_pong_ping_l       => Rx_pong_ping_l,
<        Rx_DPM_ce            => Rx_DPM_ce,
<        Rx_DPM_wr_data       => Rx_DPM_wr_data,
<        Rx_DPM_rd_data       => Rx_DPM_rd_data,
<        Rx_DPM_wr_rd_n       => Rx_DPM_wr_rd_n,
<        Rx_idle              => Rx_idle,
<        Mac_addr_ram_addr_rd => mac_addr_ram_addr_rd,
<        Mac_addr_ram_data    => mac_addr_ram_data,
<        Rx_buffer_ready      => Rx_buffer_ready
<    
<        );      
<    
<    ----------------------------------------------------------------------------
<    -- Transmit Interface
<    ----------------------------------------------------------------------------
<    TX: entity axi_ethernetlite_v1_00_a.transmit
<      generic map
<        (
<        C_DUPLEX => C_DUPLEX,
<        C_FAMILY => C_FAMILY
<        )
<      port map
<        (
<        Clk                   =>  Clk,
<        Rst                   =>  Rst,
<        NibbleLength          =>  nibbleLength,
<        NibbleLength_orig     =>  nibbleLength_orig,
<        En_pad                =>  en_pad,
<        TxClkEn               =>  txClkEn,
<        Phy_tx_clk            =>  Phy_tx_clk,
<        Phy_crs               =>  phy_crs_d1, 
<        Phy_col               =>  phy_col_d1, 
<                     
<        Phy_tx_en             =>  phy_tx_en,
<        Phy_tx_data           =>  phy_tx_data,
<        Tx_addr_en            =>  tx_addr_en,
<        Tx_start              =>  tx_start,
<        Tx_done               =>  Tx_done,
<        Tx_pong_ping_l        =>  Tx_pong_ping_l,
<        Tx_idle               =>  Tx_idle,
<        Tx_DPM_ce             =>  Tx_DPM_ce,
<        Tx_DPM_wr_data        =>  Tx_DPM_wr_data,
<        Tx_DPM_rd_data        =>  Tx_DPM_rd_data,
<        Tx_DPM_wr_rd_n        =>  Tx_DPM_wr_rd_n,
<        Transmit_start        =>  Transmit_start,
<        Mac_program_start     =>  Mac_program_start,
<        Mac_addr_ram_we       =>  mac_addr_ram_we,
<        Mac_addr_ram_addr_wr  =>  mac_addr_ram_addr_wr
<                                  
<        );              
< 
<    ----------------------------------------------------------------------------
<    -- Registerign PHY Col
<    ----------------------------------------------------------------------------
<    COLLISION_SYNC: FDR             
<      port map 
<        (
<        Q => phy_col_d1, --[out]
<        C => Clk,        --[in]
<        D => Phy_col,    --[in]
<        R => Rst         --[in]
<        );
<    
<    ----------------------------------------------------------------------------
<    -- Registerign PHY CRs
<    ----------------------------------------------------------------------------
<    C_SENSE_SYNC: FDR               
<      port map 
<        (
<        Q => phy_crs_d1, --[out]
<        C => Clk,        --[in]
<        D => Phy_crs,    --[in]
<        R => Rst         --[in]
<        );
<              
<    ----------------------------------------------------------------------------
<    -- MAC Address RAM
<    ----------------------------------------------------------------------------
<    NODEMACADDRRAMI: entity axi_ethernetlite_v1_00_a.MacAddrRAM
<       generic map 
<         (
<         MACAddr  => NODE_MAC
<         )
<       port map 
<         (
<         addr     => mac_addr_ram_addr,
<         dout     => mac_addr_ram_data,
<         din      => Tx_DPM_rd_data,
<         we       => mac_addr_ram_we,
<         Clk      => Clk
<         );
<    
<    mac_addr_ram_addr <= mac_addr_ram_addr_rd when mac_addr_ram_we = '0' else
<                         mac_addr_ram_addr_wr;
< 
<    ----------------------------------------------------------------------------
<    -- RX Address Counter for the RxBuffer
<    ----------------------------------------------------------------------------
<    RXADDRCNT: process (Clk)
<      begin
<        if Clk'event and Clk = '1' then
<          if Rst = '1' then
<            rxbuffer_addr <= (others => '0');
<          elsif rx_start = '1' then
<            rxbuffer_addr <= (others => '0');
<          elsif rx_addr_en = '1' then
<            rxbuffer_addr <= rxbuffer_addr + 1;
<          end if;
<        end if;
<      end process RXADDRCNT;
<    
<    Rx_DPM_adr <= rxbuffer_addr;
---
>    -- IP2Bus_Data generation
>    IP2BUS_DATA_GENERATE: for i in 31 downto 0 generate
>       IP2Bus_Data(i) <= ((
>                           (mdio_data_out(i) and     mdio_reg_en)
>                          ) and reg_access) ;
> 
>    end generate IP2BUS_DATA_GENERATE;
399c235
<    -- TX Address Counter for the TxBuffer (To Read)
---
>    -- Regiter Address Decoding
401,412c237,250
<    TXADDRCNT: process (Clk)
<      begin
<        if Clk'event and Clk = '1' then
<          if Rst = '1' then
<            txbuffer_addr <= (others => '0');
<          elsif tx_start = '1' then
<            txbuffer_addr <= (others => '0');
<          elsif tx_addr_en = '1' then
<            txbuffer_addr <= txbuffer_addr + 1;
<          end if;
<        end if;
<      end process TXADDRCNT;
---
>    -- This process loads data from the AXI when there is a write request and
>    -- the control register is enabled.
>    -- Register Address Space
>    -----------------------------------------
>    -- **** MDIO Registers offset ****
>    --       Address Register    => 0x07E4
>    --       Write Data Register => 0x07E8
>    --       Read Data Register  => 0x07Ec
>    --       Control Register    => 0x07F0
>    ------------------------------------------
>    -- bus2ip_addr(12 downto 0)= axi_addr (12 downto 0)
>    ----------------------------------------------------------------------------
>    reg_access_i <= '1' when bus2ip_addr(10 downto 5) = "111111"
>                  else '0';
414,416d251
<                    
<    Tx_DPM_adr <= txbuffer_addr;
<   
417a253,255
>    -- Register access enable
>    reg_en <= reg_access_i and (not Bus2IP_Burst);
>    
419c257
<    -- INT_tx_clk_sync_PROCESS
---
>    -- REG_ACCESS_PROCESS
421c259
<    -- This process syncronizes the tx Clk and generates an enable pulse
---
>    -- Registering the reg_access to break long timing path
423,424c261,262
<    INT_TX_CLK_SYNC_PROCESS : process (Clk)
<    begin  --   
---
>    REG_ACCESS_PROCESS : process (Clk)
>    begin  -- process
426,431c264,269
<          if (Rst = RESET_ACTIVE) then
<             tx_clk_reg_d1 <= '0';
<             tx_clk_reg_d2 <= '0';
<          else            
<             tx_clk_reg_d1 <= Phy_tx_clk;
<             tx_clk_reg_d2 <= tx_clk_reg_d1;
---
>          if (Rst = '1') then
>             reg_access     <= '0';
>             reg_access_d1  <= '0';
>          elsif Bus2IP_RdCE='1' then
>             reg_access     <= reg_access_i;
>             reg_access_d1  <= reg_access;
434c272
<    end process INT_TX_CLK_SYNC_PROCESS;  
---
>    end process REG_ACCESS_PROCESS;
436,439d273
<    txClkEn <= '1' when tx_clk_reg_d1 = '1' and tx_clk_reg_d2 = '0' else 
<                  '0';
< 
<   
441c275
<    -- ADJP
---
>    -- MDIO_GEN :- Include MDIO interface if the parameter C_INCLUDE_MDIO = 1
443,445c277,293
<    -- Adjust the packet length is it is less than minimum
<    ----------------------------------------------------------------------------
<    ADJP : process(mac_tx_frame_length)
---
>    MDIO_GEN: if C_INCLUDE_MDIO = 1 generate
>    
>       signal mdio_addr_en       : std_logic;
>       signal mdio_wr_data_en    : std_logic;
>       signal mdio_rd_data_en    : std_logic;
>       signal mdio_ctrl_en       : std_logic;
>       signal mdio_clause_i      : std_logic;
>       signal mdio_op_i          : std_logic_vector(1 downto 0);
>       signal mdio_en_i          : std_logic;
>       signal mdio_req_i         : std_logic;
>       signal mdio_done_i        : std_logic;
>       signal mdio_wr_data_reg   : std_logic_vector(15 downto 0);
>       signal mdio_rd_data_reg   : std_logic_vector(15 downto 0);
>       signal mdio_phy_addr      : std_logic_vector(4 downto 0);
>       signal mdio_reg_addr      : std_logic_vector(4 downto 0);
>       signal mdio_clk_i         : std_logic;
>       signal clk_cnt            : integer range 0 to 63;
447,454d294
<       if mac_tx_frame_length > MinimumPacketLength then
<          nibbleLength <= mac_tx_frame_length(5 to 15) & '0';
<          en_pad       <= '0';
<       else
<          nibbleLength <= MinimumPacketLength(5 to 15) & '0';
<          en_pad       <= '1';
<       end if;
<    end process ADJP;    
456c296,479
<    nibbleLength_orig <= mac_tx_frame_length(5 to 15) & '0';
---
>       -- MDIO reg enable
>       mdio_reg_en     <= (mdio_addr_en    or 
>                           mdio_wr_data_en or 
>                           mdio_rd_data_en or 
>                           mdio_ctrl_en       ) and (not bus2ip_burst);
>                           
>       -- MDIO address reg enable
>       mdio_addr_en    <= reg_en and (not bus2ip_addr(4))
>                                 and (not bus2ip_addr(3))
>                                 and (    bus2ip_addr(2));
> 
>       -- MDIO write data reg enable
>       mdio_wr_data_en <= reg_en and (not bus2ip_addr(4))
>                                 and (    bus2ip_addr(3))
>                                 and (not bus2ip_addr(2));
> 
>       -- MDIO read data reg enable
>       mdio_rd_data_en <= reg_en and (not bus2ip_addr(4))
>                                 and (    bus2ip_addr(3))
>                                 and (    bus2ip_addr(2));
> 
>       -- MDIO controlreg enable
>       mdio_ctrl_en    <= reg_en and (    bus2ip_addr(4))
>                                 and (not bus2ip_addr(3))
>                                 and (not bus2ip_addr(2));                          
>    
>    
>       -------------------------------------------------------------------------
>       -- MDIO_CTRL_REG_WR_PROCESS
>       -------------------------------------------------------------------------
>       -- This process loads data from the AXI when there is a write request and
>       -- the MDIO control register is enabled.
>       -------------------------------------------------------------------------
>       MDIO_CTRL_REG_WR_PROCESS : process (Clk)
>       begin  -- process
>          if (Clk'event and Clk = '1') then
>             if (Rst = '1') then
>                mdio_en_i    <= '0';
>                mdio_req_i   <= '0';
>             elsif (Bus2IP_WrCE = '1' and mdio_ctrl_en= '1') then
>                --  Load MDIO Control Register with AXI
>                --  data if there is a write request
>                --  and the control register is enabled
>                mdio_en_i    <= Bus2IP_Data(3);
>                mdio_req_i   <= Bus2IP_Data(0);
>             -- Clear the status bit when trnasmit complete
>             elsif mdio_done_i = '1' then
>                mdio_req_i   <=  '0';
>             end if;
>          end if;
>       end process MDIO_CTRL_REG_WR_PROCESS;
>    
>       -------------------------------------------------------------------------
>       -- MDIO_ADDR_REG_WR_PROCESS
>       -------------------------------------------------------------------------
>       -- This process loads data from the AXI when there is a write request and
>       -- the MDIO Address register is enabled.
>       -------------------------------------------------------------------------
>       MDIO_ADDR_REG_WR_PROCESS : process (Clk)
>       begin  -- process
>          if (Clk'event and Clk = '1') then
>             if (Rst = '1') then 
>                mdio_phy_addr <= (others =>'0');
>                mdio_reg_addr <= (others =>'0');
>                mdio_op_i     <= (others =>'0');
>                mdio_clause_i <= '0'; 
>             elsif (Bus2IP_WrCE = '1' and mdio_addr_en= '1') then               
>                --  Load MDIO ADDR Register with AXI
>                --  data if there is a write request
>                --  and the Address register is enabled
>                mdio_phy_addr <= Bus2IP_Data(9 downto 5);
>                mdio_reg_addr <= Bus2IP_Data(4 downto 0);
>                mdio_op_i     <= Bus2IP_Data(11 downto 10);
>                mdio_clause_i <= Bus2IP_Data(12);
>                
>             end if;
>          end if;
>       end process MDIO_ADDR_REG_WR_PROCESS;
>    
>       -------------------------------------------------------------------------
>       -- MDIO_WRITE_REG_WR_PROCESS
>       -------------------------------------------------------------------------
>       -- This process loads data from the AXI when there is a write request  
>       -- and the MDIO Write register is enabled.
>       -------------------------------------------------------------------------
>       MDIO_WRITE_REG_WR_PROCESS : process (Clk)
>       begin  -- process
>          if (Clk'event and Clk = '1') then
>             if (Rst = '1') then 
>                mdio_wr_data_reg <= (others =>'0');
>             elsif (Bus2IP_WrCE = '1' and mdio_wr_data_en= '1') then            
>                --  Load MDIO Write Data Register with AXI
>                --  data if there is a write request
>                --  and the Write Data register is enabled
>                mdio_wr_data_reg <= Bus2IP_Data(15 downto 0);
>                
>             end if;
>          end if;
>       end process MDIO_WRITE_REG_WR_PROCESS;
>       
>       -------------------------------------------------------------------------
>       -- MDIO_REG_RD_PROCESS
>       -------------------------------------------------------------------------
>       -- This process allows MDIO register read from the AXI when there is a
>       -- read request and the MDIO registers are enabled.
>       -------------------------------------------------------------------------
>       MDIO_REG_RD_PROCESS : process (Clk)
>       begin  -- process
>          if (Clk'event and Clk = '1') then
>             if (Rst = '1') then
>                mdio_data_out <= (others =>'0');
>             elsif (Bus2IP_RdCE = '1' and mdio_addr_en= '1') then
>                --  MDIO Address Register Read through AXI
>                mdio_data_out(4 downto 0) <= mdio_reg_addr;
>                mdio_data_out(9 downto 5) <= mdio_phy_addr;
>                mdio_data_out(11 downto 10)  <= mdio_op_i;
>                mdio_data_out(12)       <= mdio_clause_i;
>                mdio_data_out(31  downto 13) <= (others=>'0');
>             elsif (Bus2IP_RdCE = '1' and mdio_wr_data_en= '1') then
>                --  MDIO Write Data Register Read through AXI
>                mdio_data_out(15 downto 0) <= mdio_wr_data_reg;
>                mdio_data_out(31  downto 16) <= (others=>'0');
>             elsif (Bus2IP_RdCE = '1' and mdio_rd_data_en= '1') then
>                --  MDIO Read Data Register Read through AXI
>                mdio_data_out(15 downto 0) <= mdio_rd_data_reg;
>                mdio_data_out(31 downto 16) <= (others=>'0');
>             elsif (Bus2IP_RdCE = '1' and mdio_ctrl_en= '1') then
>                --  MDIO Control Register Read through AXI
>                mdio_data_out(0) <= mdio_req_i;
>                mdio_data_out(1) <= '0';
>                mdio_data_out(2) <= '0';
>                mdio_data_out(3) <= mdio_en_i;
>                mdio_data_out(31  downto 4) <= (others=>'0');
>             --else
>             --   mdio_data_out <= (others =>'0');
>             end if;
>          end if;
>       end process MDIO_REG_RD_PROCESS;
>    
>       -------------------------------------------------------------------------
>       -- PROCESS : MDIO_CLK_COUNTER 
>       -------------------------------------------------------------------------
>       -- Generating MDIO clock. The minimum period for MDC clock is 400 ns. 
>       -------------------------------------------------------------------------
>       MDIO_CLK_COUNTER : process(Clk)
>       begin
>          if (Clk'event and Clk = '1') then
>             if (Rst = '1' ) then
>                clk_cnt  <= MDIO_CNT;
>                mdio_clk_i <= '0';
>             elsif (clk_cnt = 0) then
>                clk_cnt    <= MDIO_CNT;
>                mdio_clk_i <= not mdio_clk_i;
>             else 
>                clk_cnt <= clk_cnt - 1;
>             end if;
>          end if;
>       end process;
>    
>       -------------------------------------------------------------------------
>       -- MDIO master interface module
>       -------------------------------------------------------------------------
>       MDIO_IF_I: entity nf10_mdio_v1_00_a.mdio_if
>          port map (             
>             Clk            => Clk       , 
>             Rst            => Rst     ,
>             MDIO_CLK       => mdio_clk_i       ,
>             MDIO_en        => mdio_en_i        ,
>             MDIO_Clause    => mdio_clause_i    ,
>             MDIO_OP        => mdio_op_i        ,
>             MDIO_Req       => mdio_req_i       ,
>             MDIO_PHY_AD    => mdio_phy_addr    ,      
>             MDIO_REG_AD    => mdio_reg_addr    ,
>             MDIO_WR_DATA   => mdio_wr_data_reg ,
>             MDIO_RD_DATA   => mdio_rd_data_reg ,
>             PHY_MDIO_I     => PHY_MDIO_I       ,
>             PHY_MDIO_O     => PHY_MDIO_O       ,
>             PHY_MDIO_T     => PHY_MDIO_T       ,
>             PHY_MDC        => PHY_MDC          ,
>             MDIO_done      => mdio_done_i
>             );          
>       
>    
>    end generate MDIO_GEN; 
458d480
<    mac_tx_frame_length <= Tx_packet_length;
460c482,493
<   
---
>    -- NO_MDIO_GEN :- Include MDIO interface if the parameter C_INCLUDE_MDIO = 0
>    ----------------------------------------------------------------------------
>    NO_MDIO_GEN: if C_INCLUDE_MDIO = 0 generate
>    begin
> 
>       mdio_data_out <= (others=>'0');
>       mdio_reg_en   <= '0';
>       PHY_MDIO_O    <= '0';
>       PHY_MDIO_T    <= '1';
> 
>    end generate NO_MDIO_GEN;
> 
463a497
> 
